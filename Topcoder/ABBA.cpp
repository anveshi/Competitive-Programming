#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;


class ABBA {
public:
  int fun(string s1, string s2,int n1,int n2){
    if(n2<n1)return 0;
    else if(n1==n2){
      return s1==s2;
    }
    else{
      if(s2[n2-1]=='A'){
        return fun(s1,s2.substr(0,n2-1),n1,n2-1);
      }
      else{
        string temp = s2.substr(0,n2-1);
        reverse(temp.begin(),temp.end());
        return fun(s1,temp,n1,n2-1);
      }
    }
  }
	string canObtain(string initial, string target) {
    int n1=initial.size(),n2=target.size();
    if(fun(initial, target,n1,n2))
      return "Possible";
    else
      return "Impossible";
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	ABBA *obj;
	string answer;
	obj = new ABBA();
	clock_t startTime = clock();
	answer = obj->canObtain(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	string p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = "B";
	p1 = "ABBA";
	p2 = "Possible";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "AB";
	p1 = "ABB";
	p2 = "Impossible";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "BBAB";
	p1 = "ABABABABB";
	p2 = "Impossible";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "BBBBABABBBBBBA";
	p1 = "BBBBABABBABBBBBBABABBBBBBBBABAABBBAA";
	p2 = "Possible";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "A";
	p1 = "BB";
	p2 = "Impossible";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// One day, Jamie noticed that many English words only use the letters A and B.
// Examples of such words include "AB" (short for abdominal), "BAA" (the noise a sheep makes), "AA" (a type of lava), and "ABBA" (a Swedish pop sensation).
// 
// Inspired by this observation, Jamie created a simple game.
// You are given two strings: initial and target.
// The goal of the game is to find a sequence of valid moves that will change initial into target.
// There are two types of valid moves:
// 
// Add the letter A to the end of the string.
// Reverse the string and then add the letter B to the end of the string.
// 
// 
// Return "Possible" (quotes for clarity) if there is a sequence of valid moves that will change initial into target.
// Otherwise, return "Impossible".
// 
// DEFINITION
// Class:ABBA
// Method:canObtain
// Parameters:string, string
// Returns:string
// Method signature:string canObtain(string initial, string target)
// 
// 
// CONSTRAINTS
// -The length of initial will be between 1 and 999, inclusive.
// -The length of target will be between 2 and 1000, inclusive.
// -target will be longer than initial.
// -Each character in initial and each character in target will be either 'A' or 'B'.
// 
// 
// EXAMPLES
// 
// 0)
// "B"
// "ABBA"
// 
// Returns: "Possible"
// 
// Jamie can perform the following moves:
// 
// Initially, the string is "B".
// Jamie adds an 'A' to the end of the string. Now the string is "BA".
// Jamie reverses the string and then adds a 'B' to the end of the string. Now the string is "ABB".
// Jamie adds an 'A' to the end of the string. Now the string is "ABBA".
// 
// Since there is a sequence of moves which starts with "B" and creates the string "ABBA", the answer is "Possible".
// 
// 1)
// "AB"
// "ABB"
// 
// Returns: "Impossible"
// 
// The only strings of length 3 Jamie can create are "ABA" and "BAB".
// 
// 2)
// "BBAB"
// "ABABABABB"
// 
// Returns: "Impossible"
// 
// 
// 
// 3)
// "BBBBABABBBBBBA"
// "BBBBABABBABBBBBBABABBBBBBBBABAABBBAA"
// 
// Returns: "Possible"
// 
// 
// 
// 4)
// "A"
// "BB"
// 
// Returns: "Impossible"
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
