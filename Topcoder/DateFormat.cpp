#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;


class DateFormat {
public:
	string fromEuropeanToUs(vector <string> dateList) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	DateFormat *obj;
	string answer;
	obj = new DateFormat();
	clock_t startTime = clock();
	answer = obj->fromEuropeanToUs(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	string p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"16/01"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "01/16";
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"02/01 08/02 08/02 21/09 06/11"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "01/02 02/08 08/02 09/21 11/06";
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"08/02 08/02 03/04"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "";
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"2","9/02"," 08/","03 01/08"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "02/29 03/08 08/01";
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"17/01 05/05 03/07 07/24 23/09 09/30 01/11 11/11"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "01/17 05/05 07/03 07/24 09/23 09/30 11/01 11/11";
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// In the US, dates are usually written starting with the month, but in Europe, they are usually written starting with the day. So, January 16 will be written as "01/16" in the US and as "16/01" in Europe.
// 
// You have a list of dates for the next year and it is known that the given dates are listed in strictly increasing order. Unfortunately, the list was populated by different people and it can contain dates in both formats. You want to convert all dates into the US format.
// 
// You will be given a string dateList. First, you should concatenate all elements of dateList and consider it as one string. The conjoint dateList will contain a space-separated list of the dates. Each date will be in the form "XX/XX" (quotes for clarity), where each X is a digit. 
// Convert the dates (without changing the order of the list) so that each date is in the US format and the list is in strictly increasing order.
// Note that in the original list, the format in which certain dates were written might be ambiguous.  You may interpret those dates as being in either format as long as the final list is in strictly increasing order. Return the result as a single string in the same format as the original.  If there are several solutions possible return one that comes first lexicographically. If it is impossible to obtain a strictly increasing list of dates, return an empty string.
// 
// 
// 
// DEFINITION
// Class:DateFormat
// Method:fromEuropeanToUs
// Parameters:vector <string>
// Returns:string
// Method signature:string fromEuropeanToUs(vector <string> dateList)
// 
// 
// NOTES
// -Next year is 2008, a leap year. So, February 29 is a valid date. 
// 
// 
// CONSTRAINTS
// -dateList will contain between 1 and 50 elements, inclusive.
// -Each element of dateList will contain between 1 and 50 characters, inclusive.
// -The conjoint dateList will contain a single space separated list of dates without leading or trailing spaces. 
// -Each date in dateList will be in the form "XX/XX" (quotes for clarity), where each X is a digit.
// -Each date in dateList will represent a valid date in either US format or European format. 
// 
// 
// EXAMPLES
// 
// 0)
// {"16/01"}
// 
// Returns: "01/16"
// 
// The example from the problem statement.
// 
// 1)
// {"02/01 08/02 08/02 21/09 06/11"}
// 
// Returns: "01/02 02/08 08/02 09/21 11/06"
// 
// The first date is either January 2 or February 1.
// The second date is either February 8 or August 2.
// The third date is either February 8 or August 2.
// The fourth date is definitely September 21.
// The fifth date is either June 11 or November 06.
// There are two ways to interpret these dates in strictly increasing order: "01/02 02/08 08/02 09/21 11/06" and "02/01 02/08 08/02 09/21 11/06". The first variant comes earlier lexicographically.
//  
// 
// 2)
// {"08/02 08/02 03/04"}
// 
// Returns: ""
// 
// 3)
// {"2", "9/02", " 08/", "03 01/08"}
// 
// Returns: "02/29 03/08 08/01"
// 
// 4)
// {"17/01 05/05 03/07 07/24 23/09 09/30 01/11 11/11"}
// 
// Returns: "01/17 05/05 07/03 07/24 09/23 09/30 11/01 11/11"
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
