#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


vector <string> S;
int dx[] = {1,-1,0,0};
int dy[] = {0,0,1,-1};
int N,M;
int Dp[55][55][55];
class BoardEscapeDiv2 {
public:
	bool isGood(int x,int y){
		return (x>=0 && y>=0 && x<N && y<M);
	}
	int fun(int x,int y,int z){
		cout << x << " " << y << " " << z << endl; 
		if(Dp[x][y][z]!=-1)
			return Dp[x][y][z];
		int flag = 0;
		for(int i=0;i<4;i++){
			if(isGood(x+dx[i],y+dy[i])){
				cout << x << " " << y << "         " << x+dx[i] << " " << y+dy[i] << " ";
				cout << S[x+dx[i]][y+dy[i]] << endl;
				if(S[x+dx[i]][y+dy[i]]!='#')
					flag = 1;
			}
		}
		if(flag == 0){
			cout << x << " " << y << " " << z << 0 << "a" << endl;
			return Dp[x][y][z] = 0;
		}

		for(int i=0;i<4;i++){
			if(isGood(x+dx[i],y+dy[i]) && S[x+dx[i]][y+dy[i]]=='E'){
			cout << x << " " << y << " " << z << 1 << "b" << endl;

				return Dp[x][y][z] = 1;
			}

			if(z==1 && (isGood(x+dx[i],y+dy[i]) && S[x+dx[i]][y+dy[i]]=='.')){
			cout << x << " " << y << " " << z << 1 << "c" << endl;

				return Dp[x][y][z] = 1;
			}
		}

		int Ret = 0;

		for(int i=0;i<4;i++){
			if(isGood(x+dx[i],y+dy[i])){
				if(S[x+dx[i]][y+dy[i]]=='.'){
					Ret |= (1-fun(x+dx[i],y+dy[i],z-1));
				}
			}
		}
			cout << x << " " << y << " " << z << Ret << "c" << endl;

		return Dp[x][y][z] =Ret;
	}
	string findWinner(vector <string> s, int k) {
		memset(Dp,-1,sizeof(Dp));
		int n = s.size();
		int x,y;
		int m = s[0].length();
		N = n,M=m;
		for(int i=0;i<n;i++){
			S.push_back(s[i]);
			for(int j=0;j<m;j++){
				if(s[i][j]=='T'){
					x =i;y=j;
				}
			}
		}
		S[x][y] = '.';
		if(fun(x,y,k))
			return "Alice";
		else
			return "Bob";
	}
};

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	BoardEscapeDiv2 *obj;
	string answer;
	obj = new BoardEscapeDiv2();
	clock_t startTime = clock();
	answer = obj->findWinner(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	string p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"T.#","#.E"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	p2 = "Alice";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Alice and Bob have a rectangular board divided into a grid with r rows and c columns.
// The grid is described by the vector <string> s.
// Each character of s represents one cell.
// There are four types of cells:
// 
// 'E' denotes an exit. There may be arbitrarily many exits, possibly zero.
// 'T' means the square contains a single token. Initially there will be exactly one token on the entire board.
// '#' denotes an obstacle.
// '.' denotes an empty cell.
// 
// 
// 
// 
// Alice and Bob will play a game on this board.
// The game is parameterized by the int k.
// The token initially has the number k on it.
// The players will take alternating turns, starting with Alice.
// A player's turn consists of the following steps:
// 
// The player moves the token one square up, down, left, or right. The token cannot go over the edge of the board and it cannot enter a cell with an obstacle.
// If this token is on an exit, it disappears from the board.
// Otherwise, subtract one from the number on the token. If the number on the token is zero, remove it from the board.
// 
// 
// 
// 
// The first player unable to make a move loses the game.
// (This happens when the token is stuck and also when it already left the board.)
// 
// 
// 
// You are given the vector <string> s and the int k
// Compute the winner of the game, assuming both Alice and Bob play optimally.
// Return the winner's name: either "Alice" or "Bob".
// Note that the return value is case-sensitive.
// 
// 
// DEFINITION
// Class:BoardEscapeDiv2
// Method:findWinner
// Parameters:vector <string>, int
// Returns:string
// Method signature:string findWinner(vector <string> s, int k)
// 
// 
// CONSTRAINTS
// -r,c will be between 1 and 50, inclusive.
// -s will contain exactly r elements, each consisting of c characters.
// -Each character of each element of s will be one of 'T', 'E', '#', or '.'.
// -There will be exactly 1 'T' charcters within all elements of s.
// -k will be between 1 and 100, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {"T.#",
//  "#.E"}
// 3
// 
// Returns: "Alice"
// 
// The token starts in row 0, column 0.
// At the beginning of the game the number on the token is 3.
// In her first move Alice must push the token to the right and decrease the number to 2.
// Bob can then move the token either left (back where it started) or down.
// Either way, after Bob's move the number on the token will be 1.
// Regardless of which option Bob chose, Alice can always make the token disappear in her second move:
// either she reaches the exit, or the token disappears on its own after its counter reaches zero.
// Afterwards Bob cannot make his second move and therefore Alice wins the game.
// 
// 1)
// {"E#E",
//  "#T#",
//  "E#E"}
// 99
// 
// Returns: "Bob"
// 
// As the token is stuck between obstacles, Alice has no valid move to make and therefore she immediately loses the game.
// 
// 
// 2)
// {"#E...",
//  "#...E",
//  "E.T#.",
//  "..#.."}
// 13
// 
// Returns: "Alice"
// 
// 
// 
// 3)
// {"TE"}
// 50
// 
// Returns: "Alice"
// 
// 
// 
// 4)
// {".T."}
// 1
// 
// Returns: "Alice"
// 
// 
// 
// 5)
// {"..........................",
//  "......EEE..EEE..E...E.....",
//  ".....E.....E..E.EE.EE.....",
//  "......EEE..EEE..E.E.E.....",
//  ".........E.E.E..E...E.....",
//  "......EEE..E..E.E...E.....",
//  "..........................",
//  "...E#E#E#E#E#E#E#E#E#E#...",
//  "..........................",
//  "......EEE..EEE...EEE......",
//  ".....E........E.E.........",
//  "......EEE.....E..EEE......",
//  ".....E...E...E..E...E.....",
//  "......EEE....E...EEE......",
//  "..........................",
//  "...#E#E#E#E#E#E#E#E#E#E...",
//  "..........................",
//  "....EE...E...E..E.EEE.E...",
//  "...E.....E...E..E.E...E...",
//  "...E.EE..E...EEEE.EE..E...",
//  "...E..E..E...E..E.E.......",
//  "....EE...EEE.E..E.E...E...",
//  "T........................."}
// 100
// 
// Returns: "Bob"
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
