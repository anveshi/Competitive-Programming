#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;


class TreasuresPacking {
public:
	double maximizeCost(vector <string> treasures, int W) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, double p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	TreasuresPacking *obj;
	double answer;
	obj = new TreasuresPacking();
	clock_t startTime = clock();
	answer = obj->maximizeCost(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	double p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"100 100 N","100 100 N","130 10 Y"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 150;
	p2 = 103.84615384615384;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"100 100 N","100 100 N","100 1000 Y"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 150;
	p2 = 1000.0;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"207 1459 Y","150 6867 N","694 3494 Y","417 7479 N"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 650;
	p2 = 14931.00966183575;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"350 2765 Y","258 560 Y","120 9325 N","879 302 Y","611 2674 Y","774 2273 Y","318 1572 Y"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3301;
	p2 = 19467.907849829353;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You have found a cave filled with treasures, and you want to take as much as you can.  However, you can only make one trip, so you decide to use the following strategy.  You will take the treasures with the maximal total cost, but with a total weight no greater than W.  Each treasure is characterized by its weight, cost, and whether it can be divided.  For example, a bar of gold can be divided into two smaller bars of any size (with costs proportional to the cost of the original bar), but a cut-glass bowl cannot be divided because it would become worthless.
// 
// You will be given a vector <string> treasures and an int W.  Each element of treasures will be formatted as "weight cost can_be_divided" (quotes for clarity), where weight and cost are integers and can_be_divided is either 'Y' or 'N'.  Return the total cost of the treasures you will take.
// 
// DEFINITION
// Class:TreasuresPacking
// Method:maximizeCost
// Parameters:vector <string>, int
// Returns:double
// Method signature:double maximizeCost(vector <string> treasures, int W)
// 
// 
// NOTES
// -Your return value must have an absolute or relative error less than 1e-9.
// 
// 
// CONSTRAINTS
// -W will be between 1 and 10000, inclusive.
// -treasures will contain between 1 and 50 elements, inclusive.
// -Each element of treasures will be formatted as described in the problem statement.
// -Each integer in treasures will contain no leading zeroes.
// -The weight of each treasure will be between 1 and 10000, inclusive.
// -The cost of each treasure will be between 1 and 10000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {"100 100 N", "100 100 N", "130 10 Y"}
// 150
// 
// Returns: 103.84615384615384
// 
// We can't take both of the expensive treasures because their total weight is 200, which is greater than W, and neither one can be divided.  So, we take one of the expensive treasures along with 50/130 of the cheaper dividable treasure to maximize the total cost.
// 
// 1)
// {"100 100 N", "100 100 N", "100 1000 Y"}
// 150
// 
// Returns: 1000.0
// 
// 2)
// {"207 1459 Y", "150 6867 N", "694 3494 Y", "417 7479 N"}
// 650
// 
// Returns: 14931.00966183575
// 
// 3)
// {"350 2765 Y", "258 560 Y", "120 9325 N", "879 302 Y",
//  "611 2674 Y", "774 2273 Y", "318 1572 Y"}
// 3301
// 
// Returns: 19467.907849829353
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
