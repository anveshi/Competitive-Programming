#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class Messaging {
public:
	pair <string, pair<int,int> > fun(string s){
		string ret = "";
		int a=0,b=0;
		int i;
		for(i=0;;i++){
			if(s[i]==' ')
				break;
			ret += s[i];
		}
		i++;	
		while(s[i]!=' '){
			a = a*10 +(s[i]-'0');
			i++;
		}
		i++;
		while(s[i]){
			b = b*10 + (s[i]-'0');
			i++;
		}
		return make_pair(ret,make_pair(a,b));
	}
	string getNext(vector <string> messages, int time) {
		int n = messages.size();
		int cnt[55];
		for(int i=0;i<55;i++){
			cnt[i] = 0;
		}

		vector < pair<string, pair<int,int> > > VV;
		VV.clear();
		for(int i=0;i<n;i++){
			pair <string, pair<int,int> > p;
			p = fun(messages[i]);
			//cout << p.first << " " << p.second.first <<  " " << p.second.second << endl;
			//v[p.second.second].push_back(make_pair(p.second.first,p.first));
			VV.push_back( make_pair(p.first, make_pair(p.second.first,p.second.second)));
		}
		vector <string> ans(55);
		
		for(int i=0;i<=time;i++){
			int val = -1, pp=-1;
			for(int j=0;j<VV.size();j++){
				if(cnt[j]==1)
					continue;
				int it = VV[j].second.second,ip=VV[j].second.first;
				if(it>i)
					continue;
				if(ip>pp)
					val = j,pp=ip; 
			}
			if(val!=-1){
				cnt[val]=1;
				ans[i] = VV[val].first;
			}
			else
				ans[i] = "";
		}
		/*for(int i=0;i<=time;i++){
			cout << i << " " << ans[i] << endl;		
		}	*/
		return ans[time];
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, int p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	Messaging *obj;
	string answer;
	obj = new Messaging();
	clock_t startTime = clock();
	answer = obj->getNext(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	string p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"hello 1 1","how 4 1","are 2 3","you 5 4"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = "how";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"hello 1 1","how 4 1","are 2 3","you 5 4"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	p2 = "hello";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"hello 1 1","how 4 1","are 2 3","you 5 4"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	p2 = "are";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"hello 1 1","how 4 1","are 2 3","you 5 5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	p2 = "";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"priority 9 1","be 3 1","queues 5 2","can 4 3","implemented 1 3","but 8 7","in 11 7","would 2 7","nlogn 12 8","yours 21 10","that 10 10","slower 18 10","than 14 11","can 75 11","be 50 11","much 42 13","be 30 30"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 14;
	p2 = "slower";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// In many systems, there is a need for some sort of messaging service between various components of the system.  The most common type of messaging service is probably first in/first out queue, meaning that the messages get sent out in the order that they are received.  However, different messages often have different priorities, and in our service, whenever we send out a message, we want to send out the message with the highest priority.  In this problem, you are to simulate this queue.  You will be given a vector <string>, messages, representing a number of messages that are sent to the queue.  Each element of messages will be in the format "<message> <priority> <time>", where <message> is a string of lowercase letters ('a'-'z'), <priority> is an integer representing the priority of the message, and <time> is the time that the message was received, in seconds since the system was started.  The messaging service is able to send out one message every second, if there is one in the queue.  The queue may also send out a message the same second it comes in.  Your task is to model this messaging service.  In addition to messages, you will be given an int, time, representing the number of seconds since the system was started.  Your task is to determine which message the service sends at that second and return a string representing the message sent out.  If no message is sent out at time, then you should return the empty string, "".
// 
// DEFINITION
// Class:Messaging
// Method:getNext
// Parameters:vector <string>, int
// Returns:string
// Method signature:string getNext(vector <string> messages, int time)
// 
// 
// NOTES
// -Note that, to make things simpler, each priority is distinct.
// 
// 
// CONSTRAINTS
// -messages will contain between 0 and 50 elements, inclusive.
// -Each element of messages will contain between 5 and 50 characters, inclusive.
// -Each element of messages will be formatted as "<message> <priority> <time>".
// -<message> will be a sequence of 1 or more lowercase letters ('a'-'z').
// -<priority> will be an integer with no leading zeros, between 1 and 100, inclusive.
// -Each <priority> will be distinct.
// -<time> will be an integer with no extra leading zeros between 0 and 1000, inclusive.
// -time will be between 0 and 2000, inclusive.
// -Elements of messages will be sorted in non-decreasing order, by time.
// 
// 
// EXAMPLES
// 
// 0)
// {"hello 1 1","how 4 1","are 2 3","you 5 4"}
// 1
// 
// Returns: "how"
// 
// At time = 1, both "hello" and "how" are added to the queue.  Of these, "how" has the higher priority, so it is sent.
// 
// 1)
// {"hello 1 1","how 4 1","are 2 3","you 5 4"}
// 2
// 
// Returns: "hello"
// 
// At time = 2, no new messages arrive, so the remaining message from time 1 is sent.
// 
// 2)
// {"hello 1 1","how 4 1","are 2 3","you 5 4"}
// 3
// 
// Returns: "are"
// 
// At time = 3, the queue starts out empty, and then receives a single message, "are".  Since there is only one message in the queue to send, it is sent on.
// 
// 3)
// {"hello 1 1","how 4 1","are 2 3","you 5 5"}
// 4
// 
// Returns: ""
// 
// At time = 4, the queue is empty.
// 
// 4)
// {"priority 9 1",
// "be 3 1",
// "queues 5 2",
// "can 4 3",
// "implemented 1 3",
// "but 8 7",
// "in 11 7",
// "would 2 7",
// "nlogn 12 8",
// "yours 21 10",
// "that 10 10",
// "slower 18 10",
// "than 14 11",
// "can 75 11",
// "be 50 11",
// "much 42 13",
// "be 30 30"}
// 14
// 
// Returns: "slower"
// 
// Here is what the queue would send at each time step.  (Note the hint and don't try to implement a heap)
// 
// Time | Message sent ('_' means no message was sent)
// -----+--------------
//  0   | _ 
//  1   | priority
//  2   | queues
//  3   | can
//  4   | be
//  5   | implemented
//  6   | _ 
//  7   | in
//  8   | nlgn
//  9   | but
//  10  | yours
//  11  | can
//  12  | be
//  13  | much
//  14  | slower
//  15  | that
//  16  | than
//  17  | would
//  18  | _ 
//  ... | _ 
//  30  | be
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
