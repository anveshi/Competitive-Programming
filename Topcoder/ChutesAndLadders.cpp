#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;


class ChutesAndLadders {
public:
	vector <double> winningChance(vector <int> startLadder, vector <int> endLadder, vector <int> players) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, vector <int> p2, bool hasAnswer, vector <double> p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	ChutesAndLadders *obj;
	vector <double> answer;
	obj = new ChutesAndLadders();
	clock_t startTime = clock();
	answer = obj->winningChance(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p3.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p3[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p3.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != answer[i] || fabs(p3[i] - answer[i]) > 1e-9 * max(1.0, fabs(p3[i]))) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	vector <int> p2;
	vector <double> p3;
	
	{
	// ----- test 0 -----
	p0.clear() /*{}*/;
	p1.clear() /*{}*/;
	int t2[] = {0,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	double t3[] = {0.6063557826968836,0.3936442173031164};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {7,23,42,58,87};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {35,91,11,31,22};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,0,0,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	double t3[] = {0.2850398049975441,0.2591808222220256,0.23726366951493458,0.21851570326549555};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0.clear() /*{}*/;
	p1.clear() /*{}*/;
	int t2[] = {0,30};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	double t3[] = {0.013280440302841312,0.9867195596971587};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {79,70,50,27,3,8,35,20,97,94,92,86,53,63,61,46,48,15};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {98,90,66,83,13,30,43,41,77,74,72,23,52,59,18,25,10,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {21,32,56,41};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	double t3[] = {0.17890364754713348,0.13868643400691752,0.5037066355391879,0.17870328290676118};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// The board game Chutes and Ladders consists of 100 spaces, numbered 0 through 99.  Initially, each player
// begins on the space 0.  Each player takes turns rolling a pair of typical six-sided dice, and moves the
// number of spaces indicated on the dice.  Each space of the board might be the start of a chute or a ladder,
// which immediately warps the player backward or forward to another space on the board.  Once a player reaches
// or passes the last space on the board, that player wins the game.
// 
// Any space on the board, except for the first (0) or last (99) space, may be the start of a chute, a ladder, or neither.  No space will have both a chute and a ladder, and no space will have more than one chute or ladder.  A space that begins a chute or ladder will not be the end of another chute or ladder.  Furthermore, no two adjacent spaces will both have a chute and/or ladder.
// A space may, however, be the landing space of more than one chute and/or ladder.
// There will be, at most, 20 chutes/ladders on the board
// 
// You are given vector <int>s startLadder and endLadder, whose corresponding elements define
// the starting and ending points of each of the chutes and ladders on the game board.  For instance,
// startLadder[0] is the space that has a chute/ladder which ends at endLadder[0].  You are also given
// a vector <int> players indicating the current position of each player on the board.  Player 0
// will roll next, followed by player 1, etc.
// 
// You are to return a vector <double> indicating the probability of each player winning the game.
// 
// DEFINITION
// Class:ChutesAndLadders
// Method:winningChance
// Parameters:vector <int>, vector <int>, vector <int>
// Returns:vector <double>
// Method signature:vector <double> winningChance(vector <int> startLadder, vector <int> endLadder, vector <int> players)
// 
// 
// NOTES
// -The return value must be within 1e-9 absolute or relative error of the actual result.
// 
// 
// CONSTRAINTS
// -startLadder will contain between 0 and 20 elements, inclusive.
// -endLadder will contain the same number of elements as startLadder.
// -Each element of startLadder will be between 1 and 98, inclusive.
// -Each element of endLadder will be between 0 and 98, inclusive.
// -No two elements of startLadder will be the same.
// -No two elements of startLadder will differ by 1.
// -No element of endLadder will equal an element of startLadder.
// -players will contain between 2 and 4 elements, inclusive.
// -Each element of players will be between 0 and 98, inclusive.
// -No element of player will equal an element of startLadder.
// 
// 
// EXAMPLES
// 
// 0)
// {}
// {}
// {0, 0}
// 
// Returns: {0.6063557826968836, 0.3936442173031164 }
// 
// With no chutes or ladders to worry about, this is just a straight ahead race to the finish.  As expected, the first player has an advantage.
// 
// 1)
// { 7, 23, 42, 58, 87}
// {35, 91, 11, 31, 22}
// {0, 0, 0, 0}
// 
// Returns: {0.2850398049975441, 0.2591808222220256, 0.23726366951493458, 0.21851570326549555 }
// 
// Here, we've got a few chutes and ladders, and more players, which evens out the odds a bit.
// 
// 2)
// {}
// {}
// {0, 30}
// 
// Returns: {0.013280440302841312, 0.9867195596971587 }
// 
// With the second player starting a good way through the game, he has an advantage in spite of rolling second.
// 
// 3)
// {79, 70, 50, 27,  3,  8, 35, 20, 97, 94, 92, 86, 53, 63, 61, 46, 48, 15}
// {98, 90, 66, 83, 13, 30, 43, 41, 77, 74, 72, 23, 52, 59, 18, 25, 10,  5}
// {21, 32, 56, 41}
// 
// Returns: {0.17890364754713348, 0.13868643400691752, 0.5037066355391879, 0.17870328290676118 }
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
