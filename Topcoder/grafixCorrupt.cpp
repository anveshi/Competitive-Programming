#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class grafixCorrupt {
public:
	int selectWord(vector <string> dictionary, string candidate) {
		int ret = 0;
		int M = 0,flag=0;
		for(int i=0;i<dictionary.size();i++){
			int common = 0;
			for(int j=0;j<candidate.size();j++){
				if(candidate[j]==dictionary[i][j]){
					common++;
					flag=1;		
				}
			}	
			if(common>M){
				ret = i;M=common;
			}
		}
		if(!flag){
			return -1;
		}	
		return ret;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, string p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	grafixCorrupt *obj;
	int answer;
	obj = new grafixCorrupt();
	clock_t startTime = clock();
	answer = obj->selectWord(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	string p1;
	int p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"cat","cab","lab"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "dab";
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"cat","cab","lab"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "lag";
	p2 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"cat","cab","lab"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "bic";
	p2 = -1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"zkv","izs","fed","waa","ttx","bgt","quy","dtq","dgo","yrs","cid","nln","pvz","txt","zun","erd","jen","klh","kxy","emf","mqt","lza","dzb","ndx","vfr","jhs","dkm","elb"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "cwd";
	p2 = 10;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"zhadjsg","vzptftx","fbaslxs","ejejncm","xpxkeae","ixrrtzw","ovctbzx","sfzekhh","lxzixjk","jixdpik","bkianck","laclyin","uqmdkfx","dimswqo","fojhetr","grntrce","obdtqwx","bhojwcy","zuuuvst","mvqtoly","aftmupx","govuidx","qklpret","yptccki","uxdnslh","wudrusz","uwxbvou","ouytqun","pjdexqe","xraaqdw","lxmoncl","sjnjfgb","qrlqgvc","fgvoadm","yohsrxw","udpvrsr","mklucgt"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "vklikgf";
	p2 = 36;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// 
// In the grafix file format, a bitmap is encoded as a
// sequence of lowercase alphabetic words. All of these words are drawn from
// a dictionary that has been built specially for the bitmap by a compression
// algorithm. Each word in the dictionary has the same length.
// 
// 
// 
// 
// 
// It can occur that words in a grafix file are corrupted by poor
// transmission or storage media. In such cases, grafix attempts to
// reconstruct the original file by matching each corrupted word to a
// dictionary word that contains one or more of the same characters at the same
// positions.
// 
// 
// 
// 
// You are given a vector <string>, dictionary, containing
// every word in a grafix file's dictionary, and a string,
// candidate, which is a possibly corrupted word in that file. If
// there is no dictionary word that has at least one character in the
// same position as candidate, then return the int
// value -1. Otherwise, return the zero-based index of the dictionary word
// that has the greatest number of characters at the same positions as
// candidate. In the event of a tie, favor the lowest index.
// 
// 
// 
// 
// DEFINITION
// Class:grafixCorrupt
// Method:selectWord
// Parameters:vector <string>, string
// Returns:int
// Method signature:int selectWord(vector <string> dictionary, string candidate)
// 
// 
// CONSTRAINTS
// -dictionary contains between 1 and 50 elements, inclusive
// -candidate is between 1 and 20 characters long, inclusive
// -each element of dictionary has the same length as candidate
// -only the characters 'a' to 'z' are permitted in candidate and dictionary
// 
// 
// EXAMPLES
// 
// 0)
// {"cat", "cab", "lab"}
// "dab"
// 
// Returns: 1
// 
// The word "dab" has two letters in the same position as both "cab" and "lab", but "cab" comes first.
// 
// 1)
// {"cat", "cab", "lab"}
// "lag"
// 
// Returns: 2
// 
// Here, "lab" is the best fit.
// 
// 2)
// {"cat", "cab", "lab"}
// "bic"
// 
// Returns: -1
// 
// The word "bic" contains a 'c' and a 'b', but neither character is at the same position in any dictionary word.
// 
// 3)
// {"zkv", "izs", "fed", "waa", "ttx", "bgt", "quy", "dtq", "dgo", "yrs",
//  "cid", "nln", "pvz", "txt", "zun", "erd", "jen", "klh", "kxy", "emf",
//  "mqt", "lza", "dzb", "ndx", "vfr", "jhs", "dkm", "elb"}
// "cwd"
// 
// Returns: 10
// 
// 4)
// {"zhadjsg", "vzptftx", "fbaslxs", "ejejncm", "xpxkeae", "ixrrtzw",
//  "ovctbzx", "sfzekhh", "lxzixjk", "jixdpik", "bkianck", "laclyin",
//  "uqmdkfx", "dimswqo", "fojhetr", "grntrce", "obdtqwx", "bhojwcy",
//  "zuuuvst", "mvqtoly", "aftmupx", "govuidx", "qklpret", "yptccki",
//  "uxdnslh", "wudrusz", "uwxbvou", "ouytqun", "pjdexqe", "xraaqdw",
//  "lxmoncl", "sjnjfgb", "qrlqgvc", "fgvoadm", "yohsrxw", "udpvrsr",
//  "mklucgt"}
// "vklikgf"
// 
// Returns: 36
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
