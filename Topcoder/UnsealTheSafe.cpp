#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <string.h>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;
int c[10][10];
LL dp[33][10];
class UnsealTheSafe {
public:
	long long countPasswords(int N) {
		c[0][7]=c[1][2]=c[1][4]=c[2][1]=c[2][3]=c[2][5]=c[3][2]=c[3][6]=
		c[4][1]=c[4][5]=c[4][7]=c[5][2]=c[5][4]=c[5][6]=c[5][8]=c[6][3]=
		c[6][5]=c[6][9]=c[7][4]=c[7][8]=c[7][0]=c[8][5]=c[8][7]=c[8][9]=
		c[9][6]=c[9][8]=1;
	memset(dp,0,sizeof(dp));
	for(int i=0;i<10;i++)dp[0][i]=1;
	for(int i=1;i<N;i++){
		for(int j=0;j<10;j++){
			LL sum=0;
			for(int k=0;k<10;k++){
				if(c[j][k]==1)
					sum+=dp[i-1][k];
			}
			dp[i][j]=sum;
		}
	}
	LL ans=0LL;
	for(int i=0;i<10;i++)ans+=dp[N-1][i];
	return ans;	
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, bool hasAnswer, long long p1) {
	cout << "Test " << testNum << ": [" << p0;
	cout << "]" << endl;
	UnsealTheSafe *obj;
	long long answer;
	obj = new UnsealTheSafe();
	clock_t startTime = clock();
	answer = obj->countPasswords(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	long long p1;
	
	{
	// ----- test 0 -----
	p0 = 2;
	p1 = 26ll;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 3;
	p1 = 74ll;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 25;
	p1 = 768478331222ll;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// This problem contains an image that can be viewed in the applet.
// 
// A door of a safe is locked by a password. Josh witnessed an employee opening the safe. Here is the information Josh spied.
// 
// The password is a sequence containing exactly N digits..
// The password is entered using the keypad shown in the picture below.
// Every pair of neighboring digits in the password is adjacent on the keypad.  Two digits are adjacent on the keypad if they are distinct and have a common edge.
// 
// 
// 
// 
// 
// 
// Josh has evil intentions of unsealing the safe, but before he can realize his plan, he wants to know how many different passwords exist.  Given the value for N, return the number of possible passwords that satisfy all the constraints given above.
// 
// 
// 
// DEFINITION
// Class:UnsealTheSafe
// Method:countPasswords
// Parameters:int
// Returns:long long
// Method signature:long long countPasswords(int N)
// 
// 
// CONSTRAINTS
// -N will be between 2 and 30, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 
// Returns: 26
// 
// 
// if the first button is 1, the second button can be either 2 or 4
// if the first button is 2, the second button can be either 1, 3 or 5
// if the first button is 3, the second button can be either 2 or 6
// if the first button is 4, the second button can be either 1, 5 or 7
// if the first button is 5, the second button can be either 2, 4, 6 or 8
// 
// if the first button is 6, the second button can be either 3, 5 or 9
// if the first button is 7, the second button can be either 4, 8 or 0
// if the first button is 8, the second button can be either 5, 7 or 9
// if the first button is 9, the second button can be either 6 or 8
// if the first button is 0, the second button can be 7 only
// 
// 
// 
// 1)
// 3
// 
// Returns: 74
// 
// 2)
// 25
// 
// Returns: 768478331222
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
