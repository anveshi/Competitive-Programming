#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;
const LL Maxn = 1000005;	
LL C[Maxn];
LL ans[Maxn];
LL b[Maxn];
class EllysSuperMario {
public:
	int left (int p) { return p << 1; }
// same as binary heap operations
int right(int p) { return (p << 1) + 1; }
void build(int p, int L, int R) {
// O(n)
if (L == R)
// as L == R, either one is fine
st[p] = L;
// store the index
else {
// recursively compute the values
build(left(p) , L
, (L + R) / 2);
build(right(p), (L + R) / 2 + 1, R
);
int p1 = st[left(p)], p2 = st[right(p)];
st[p] = (A[p1] <= A[p2]) ? p1 : p2;
} }
int rmq(int p, int L, int R, int i, int j) {
// O(log n)
if (i > R || j < L) return -1; // current segment outside query range
if (L >= i && R <= j) return st[p];
// inside query range
// compute the min position in the left and right part of the interval
int p1 = rmq(left(p) , L
, (L+R) / 2, i, j);
int p2 = rmq(right(p), (L+R) / 2 + 1, R
, i, j);
if (p1 == -1) return p2;
// if we try to access segment outside query
if (p2 == -1) return p1;
// same as above
return (A[p1] <= A[p2]) ? p1 : p2;
// as in build routine
}

	long long getMin(int N, int K, int F, int A, int B, int M) {
		C[0] = F;
		for(int i=1;i<N;i++){
			C[i] = (C[i-1]*A + B)%M;
		}
		build(1,0,n-1);
		ans[0] = C[0];
		for(int i=1;i<=n;i++){
			ans[i] = range_min(max(0,i-k),i-1);
		}
		return ans[n];
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, int p4, int p5, bool hasAnswer, long long p6) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4 << "," << p5;
	cout << "]" << endl;
	EllysSuperMario *obj;
	long long answer;
	obj = new EllysSuperMario();
	clock_t startTime = clock();
	answer = obj->getMin(p0, p1, p2, p3, p4, p5);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p6 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p6;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	int p5;
	long long p6;
	
	{
	// ----- test 0 -----
	p0 = 6;
	p1 = 2;
	p2 = 4;
	p3 = 5;
	p4 = 3;
	p5 = 16;
	p6 = 16ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 10;
	p1 = 13;
	p2 = 6;
	p3 = 6;
	p4 = 6;
	p5 = 13;
	p6 = 0ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 15;
	p1 = 5;
	p2 = 5;
	p3 = 5;
	p4 = 5;
	p5 = 25;
	p6 = 15ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 20;
	p1 = 4;
	p2 = 133;
	p3 = 61;
	p4 = 177;
	p5 = 240;
	p6 = 327ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 1234567;
	p1 = 1337;
	p2 = 12345;
	p3 = 42;
	p4 = 666;
	p5 = 12345678;
	p6 = 18125856ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Elly plays a modified version of Super Mario. In the game the player must pass over N cells, potentially stepping on some of them. The girl starts to the left of the leftmost cell and her goal is to go beyond the rightmost one. At each move she can jump between 1 and K cells to the right of her current position. Each cell has associated price Ci. When the player steps on a cell she must pay this amount of coins. The goal of the game is to minimize the total amount of coins paid.
// 
// Imagine a level of this game with N = 6 cells with respective prices (4, 7, 6, 1, 8, 11) and maximal jump K = 2. In the first move the girl can jump on the first or second cell (paying, respectively, 4 or 7 coins). Elly would chose the second one, paying more, but going further to the right. Her next jump should be to the fourth cell (paying one more coin); then just a short jump to the fifth cell (paying 8 coins); and finally jumping outside the board. The total amount of coins she pays is 7 + 1 + 8 = 16, which is also the minimum that can be achieved for this level.
// You want to help Elly by writing a program that finds the path with minimal cost. The girl has provided you with the information about the level she is currently playing. This includes the int N and int K, as well as four ints F, A, B, and M. The leftmost cell of the level has price F. Each consecutive cell is generated by the formula Ci = (Ci-1 * A + B) % M, where % denotes the modulo operation. Return the minimal amount of coins that must be paid in order to reach the right end of the level.
// 
// DEFINITION
// Class:EllysSuperMario
// Method:getMin
// Parameters:int, int, int, int, int, int
// Returns:long long
// Method signature:long long getMin(int N, int K, int F, int A, int B, int M)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 10,000,000, inclusive.
// -K will be between 1 and 1,000,000, inclusive.
// -M will be between 1 and 1,000,000,007, inclusive.
// -F, A, and B will be between 0 and M-1, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 6
// 2
// 4
// 5
// 3
// 16
// 
// Returns: 16
// 
// This is the example from the problem statement - the generated numbers are (4, 7, 6, 1, 8, 11) and the maximal jump is 2 cells.
// 
// 1)
// 10
// 13
// 6
// 6
// 6
// 13
// 
// Returns: 0
// 
// When K is greater than N, Elly can simply jump over all of the cells for free.
// 
// 2)
// 15
// 5
// 5
// 5
// 5
// 25
// 
// Returns: 15
// 
// Sometimes the game levels can be a bit boring.
// 
// 3)
// 20
// 4
// 133
// 61
// 177
// 240
// 
// Returns: 327
// 
// 
// 
// 4)
// 1234567
// 1337
// 12345
// 42
// 666
// 12345678
// 
// Returns: 18125856
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
