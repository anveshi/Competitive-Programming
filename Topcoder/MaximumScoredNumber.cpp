#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair
using namespace std;
int dp[20010];
class MaximumScoredNumber {
public:
	int getNumber(int lowerBound, int upperBound) {
		for(int i=0;i<101;i++){
			for(int j=i;j<101;j++){
				dp[i*i+j*j]++;
			}
		}
	int ans = lowerBound;int value=0;
	for(int i=lowerBound;i<=upperBound;i++){
		if(dp[i]>=value){
			value = dp[i];
			ans =  i;
		}
	}
	return ans;	
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(i	nt testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	MaximumScoredNumber *obj;
	int answer;
	obj = new MaximumScoredNumber();
	clock_t startTime = clock();
	answer = obj->getNumber(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 0;
	p1 = 2;
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 0;
	p1 = 30;
	p2 = 25;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 0;
	p1 = 0;
	p2 = 0;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 5;
	p1 = 99;
	p2 = 85;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 0;
	p1 = 10000;
	p2 = 9425;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// In her favorite Math class, Little Bonnie learned that some non-negative integers can be represented as the sum of the squares of two non-negative integers. For example, 13 can be represented as 2*2 + 3*3.
// 
// 
// Bonnie later discovered that some of those integers can even be represented by more than one possible pair.  For example, 25 can be represented as 0*0 + 5*5, and it can also be represented as 3*3 + 4*4.
// 
// 
// She has defined the score of an integer as the number of different ways it can be represented as the sum of the squares of two non-negative integers.  The order of the two squared integers is not important.  In other words, a*a + b*b is equivalent to b*b + a*a, so they should only count once in the score.  So, 25 has a score of 2, 2 has a score of 1 (2 = 1*1 + 1*1), 1 also has a score of 1 (1 = 0*0 + 1*1) and 3 has a score of 0.
// 
// 
// Bonnie needs your help in solving the following problem. She wants to find the integer between lowerBound and upperBound, inclusive, with the maximum score.  If multiple integers have the same highest score, return the largest among them.
// 
// DEFINITION
// Class:MaximumScoredNumber
// Method:getNumber
// Parameters:int, int
// Returns:int
// Method signature:int getNumber(int lowerBound, int upperBound)
// 
// 
// CONSTRAINTS
// -upperBound will be between 0 and 10000, inclusive.
// -lowerBound will be between 0 and upperBound, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 0
// 2
// 
// Returns: 2
// 
// In the range 0 to 2, the numbers have the following scores:
// 
// 0 has a score of 1: 0 = 0*0 + 0*0 
// 1 has a score of 1: 1 = 0*0 + 1*1 
// 2 has a score of 1: 2 = 1*1 + 1*1 
// 
// All of them have the same score. Number 2 is the biggest so it is returned.
// 
// 1)
// 0
// 30
// 
// Returns: 25
// 
// 25 is the only number between 0 and 30 having a score of 2.
// 
// 2)
// 0
// 0
// 
// Returns: 0
// 
// 
// 
// 3)
// 5
// 99
// 
// Returns: 85
// 
// 
// 
// 4)
// 0
// 10000
// 
// Returns: 9425
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
