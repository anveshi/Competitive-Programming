#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class RailroadSwitchOperator {
public:
	int minEnergy(int N, vector <int> x, vector <int> t) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	RailroadSwitchOperator *obj;
	int answer;
	obj = new RailroadSwitchOperator();
	clock_t startTime = clock();
	answer = obj->minEnergy(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	int p3;
	
	{
	// ----- test 0 -----
	p0 = 2;
	int t1[] = {1,2,1,2,1,2,1,2};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,2,3,4,5,6,7,8};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 7;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 4;
	int t1[] = {1,4,4,4,4,4,4,4,4,4};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,2,4,8,16,32,64,128,256,512};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 1;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 32;
	int t1[] = {2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 20;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 131072;
	int t1[] = {1,1,1,1,1,1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {10,300,500,676,800,950,1000};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 0;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 1024;
	int t1[] = {1,1024,2,512,4,256,8,128,16,64,32};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,2,3,5,8,13,21,34,55,89,144};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = 10;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Alice is a railroad switch operator.
// She is in charge of a network of rails that has the topology of a perfectly balanced binary tree with N leaves.
// N is a power of two.
// Each non-leaf node of the tree has a left child and a right child.
// The leaves are numbered from 1 to N from the left to the right.
// 
// 
// 
// There will be some trains that will pass through Alice's railroad network.
// Each of these trains will enter the network in the root of the tree and leave it in one of the leaves.
// Each non-leaf node contains a railroad switch that can send an incoming train either towards the left child or towards the right child of that node.
// Initially all switches point to the left.
// 
// 
// 
// You are given the information about the trains in vector <int>s x and t.
// For each valid i there will be a train that appears in the root node at time t[i] and wishes to reach the leaf x[i].
// All the t[i] are distinct.
// Alice must direct all trains to their desired destinations by flipping all the necessary switches.
// 
// 
// 
// More formally, for each integer z = 1, 2, 3, ... the following steps happen, in order:
// 
// If there is a train with t[i] = z, at time z that train will appear in the root.
// Immediately after that happens, Alice decides whether she wants to take an action. If she doesn't, nothing happens. If she does, she may flip as many switches as she likes. All these flips happen in an instant.
// All trains leave their current nodes according to the state of the switches in those nodes.
// During the time interval (z, z+1) each train travels along an edge of the tree to the next node.
// Any train that just reached a leaf leaves the network.
// 
// 
// 
// 
// Alice must route all trains to their desired destinations.
// Given this requirement, she would like to minimize the number of actions she has to take.
// (Note that she only cares about the number of actions. The total number of times a switch is flipped does not matter.)
// 
// 
// 
// Compute and return the smallest number of actions Alice has to take in order to route all trains correctly.
// 
// 
// DEFINITION
// Class:RailroadSwitchOperator
// Method:minEnergy
// Parameters:int, vector <int>, vector <int>
// Returns:int
// Method signature:int minEnergy(int N, vector <int> x, vector <int> t)
// 
// 
// CONSTRAINTS
// -N will be a power of 2 between 2 and 131,072 (= 2^17), inclusive.
// -The number of elements in t will be between 1 and 2,500, inclusive.
// -x will have exactly the same number of elements as t.
// -Each element of x will be between 1 and N, inclusive.
// -Each element of t will be between 1 and 5,000, inclusive.
// -t[i] < t[i+1] for all valid i.
// 
// 
// EXAMPLES
// 
// 0)
// 2
// {1,2,1,2,1,2,1,2}
// {1,2,3,4,5,6,7,8}
// 
// Returns: 7
// 
// This network is very simple: one root and two leaves.
// Trains appear in the root at time 1, 2, ..., 8.
// The first train can use the default setting of the switch.
// For each of the 7 remaining trains Alice must take an action to flip the switch.
// 
// 1)
// 4
// {1,4,4,4,4,4,4,4,4,4}
// {1,2,4,8,16,32,64,128,256,512}
// 
// Returns: 1
// 
// 
// 
// 2)
// 32
// {2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31}
// {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32}
// 
// Returns: 20
// 
// 
// 
// 3)
// 131072
// {1,1,1,1,1,1,1}
// {10,300,500,676,800,950,1000}
// 
// Returns: 0
// 
// 
// 
// 4)
// 1024
// {1,1024,2,512,4,256,8,128,16,64,32}
// {1,2,3,5,8,13,21,34,55,89,144}
// 
// Returns: 10
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
