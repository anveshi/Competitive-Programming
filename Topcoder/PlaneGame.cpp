#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class PlaneGame {
public:
	int bestShot(vector <int> x, vector <int> y) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	PlaneGame *obj;
	int answer;
	obj = new PlaneGame();
	clock_t startTime = clock();
	answer = obj->bestShot(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	
	{
	// ----- test 0 -----
	int t0[] = {0,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,-1,1,1,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,-1,-1,1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,0,0,1,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,1,-1,0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {0,-3,3,3,-3,0,0,3,-3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,-3,-3,3,3,3,-3,0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {-1000000,-1,999998,1,-1001,1000000,-999999,999999,0,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {1000000,1,1000000,-1,-999,1000000,0,0,-999999,999999};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 5;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Jerry is playing a rather plain computer game. The game is played in the 2D Cartesian plane. At the beginning of the game there are some points in the plane. You are given their coordinates in the vector <int>s x and y. That is, for each valid i there is a point at (x[i], y[i]).
// 
// The objective of the game is to make a single shot that will eliminate as many of these points as possible. When Jerry takes the shot, it will eliminate all points that (at that moment) lie on the x-axis and also all points that lie on the y-axis.
// 
// Before Jerry takes the shot, he may perform a sequence of zero or more actions. Each action can be of either of the following two types:
// 
// He may translate all points by any vector (the same for all points). In other words, he may shift all points in the same direction by the same distance.
// He may rotate all points around the origin by any angle (the same for all points).
// 
// 
// Note that it is possible that after an action some points will have non-integer coordinates.
// 
// Find and return the maximum number of points Jerry can eliminate in one shot.
// 
// 
// DEFINITION
// Class:PlaneGame
// Method:bestShot
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int bestShot(vector <int> x, vector <int> y)
// 
// 
// CONSTRAINTS
// -x will contain between 1 and 50 elements, inclusive.
// -y will contain the same number of elements as x.
// -Each element of x and y will be between -1,000,000 and 1,000,000, inclusive.
// -No two points will have the same coordinates.
// 
// 
// EXAMPLES
// 
// 0)
// {0, 5}
// {0, 5}
// 
// Returns: 2
// 
// At the beginning of the game there are two points: one at (0, 0) and the other at (5, 5). Jerry can shift both points by 5 in the negative y direction. This will move the points to (0, -5) and (5, 0). Then Jerry can take the shot and eliminate both points. 
// Therefore, the answer is 2.
// 
// 1)
// {0, -1, 1, 1, -1}
// {0, -1, -1, 1, 1}
// 
// Returns: 5
// 
// 
// 
// 2)
// {0, 0, 0, 1, -1}
// {0, 1, -1, 0, 0}
// 
// Returns: 5
// 
// 
// 
// 3)
// {0, -3, 3, 3, -3, 0, 0, 3, -3}
// {0, -3, -3, 3, 3, 3, -3, 0, 0}
// 
// Returns: 5
// 
// 
// 
// 4)
// {0}
// {0}
// 
// Returns: 1
// 
// 
// 
// 5)
// {-1000000, -1, 999998, 1, -1001, 1000000, -999999, 999999, 0, 0}
// {1000000, 1, 1000000, -1, -999, 1000000, 0, 0, -999999, 999999}
// 
// Returns: 5
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
