#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair
int xxx=0;
using namespace std;


class ABBADiv1 {
  public:
  	int findseedha(string s1, string s2,int n1,int n2){
  		for(int i=0;i<=n2-n1;i++){
  			for(int j=0;j<n1;j++){
  				if(s1[j]==s2[j+i]){
  					if(j==n1-1)
  						return 1;
  				}
  				else break;
  			}
  		}
  		return 0;
  	}
    int fun(string s1, int n1, int a1,string s2,int n2,int a2,bool flag){
      if(xxx)return 1;
      if(n2<n1|| a2<a1|| n2-a2<n1-a1)return 0;
      else if(n1==n2){
        if(s1==s2){
        	xxx=1;
          return 1;
        }
        else 
          return 0;
      }
      else{
        int b1,b2;string s3="";
        b1 = n1 - a1;b2 = n2- a2;
        int z;
        z = (b2-b1)%2;
        z^=flag;
        if(z==1)
        	s3=s1;
        else{
        	for(int i=0;i<n1;i++){
        		s3+=s1[n1-i-1];
        	}
        }
        if((b2-b1)%2==0){
          if(findseedha(s3,s2,n1,n2)==0)return 0;
        }
        return (fun(s1+"A",n1+1,a1+1,s2,n2,a2,flag) || fun(s1+"B",n1+1,a1,s2,n2,a2,flag^1));
      }
    }
    string canObtain(string initial, string target) {
      int n1,n2,a1=0,a2=0;
      n1 = initial.length();
      n2 = target.length();
      for(int i=0;i<n1;i++)if(initial[i]=='A')a1++;
      for(int i=0;i<n2;i++)if(target[i]=='A')a2++;
      if(fun(initial, n1, a1,target,n2,a2,0)==1)
        return "Possible";
      else
        return "Impossible";
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2) {
  cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	ABBADiv1 *obj;
	string answer;
	obj = new ABBADiv1();
	clock_t startTime = clock();
	answer = obj->canObtain(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	string p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = "A";
	p1 = "BABA";
	p2 = "Possible";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "BAAAAABAA";
	p1 = "BAABAAAAAB";
	p2 = "Possible";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "A";
	p1 = "ABBA";
	p2 = "Impossible";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "AAABBAABB";
	p1 = "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB";
	p2 = "Possible";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "AAABAAABB";
	p1 = "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB";
	p2 = "Impossible";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// One day, Jamie noticed that many English words only use the letters A and B.
// Examples of such words include "AB" (short for abdominal), "BAA" (the noise a sheep makes), "AA" (a type of lava), and "ABBA" (a Swedish pop sensation).
// 
// Inspired by this observation, Jamie created a simple game.
// You are given two strings: initial and target.
// The goal of the game is to find a sequence of valid moves that will change initial into target.
// There are two types of valid moves:
// 
// Add the letter A to the end of the string.
// Add the letter B to the end of the string and then reverse the entire string. (After the reversal the newly-added B becomes the first character of the string).
// 
// 
// Return "Possible" (quotes for clarity) if there is a sequence of valid moves that will change initial into target.
// Otherwise, return "Impossible".
// 
// DEFINITION
// Class:ABBADiv1
// Method:canObtain
// Parameters:string, string
// Returns:string
// Method signature:string canObtain(string initial, string target)
// 
// 
// CONSTRAINTS
// -The length of initial will be between 1 and 49, inclusive.
// -The length of target will be between 2 and 50, inclusive.
// -target will be longer than initial.
// -Each character in initial and each character in target will be either 'A' or 'B'.
// 
// 
// EXAMPLES
// 
// 0)
// "A"
// "BABA"
// 
// Returns: "Possible"
// 
// Jamie can perform the following moves:
// 
// Initially, the string is "A".
// Jamie adds a 'B' to the end of the string and then reverses the string. Now the string is "BA".
// Jamie adds a 'B' to the end of the string and then reverses the string. Now the string is "BAB".
// Jamie adds an 'A' to the end of the string. Now the string is "BABA".
// 
// Since there is a sequence of moves which starts with "A" and creates the string "BABA", the answer is "Possible".
// 
// 1)
// "BAAAAABAA"
// "BAABAAAAAB"
// 
// Returns: "Possible"
// 
// Jamie can add a 'B' to the end of the string and then reverse the string.
// 
// 2)
// "A"
// "ABBA"
// 
// Returns: "Impossible"
// 
// 
// 
// 3)
// "AAABBAABB"
// "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB"
// 
// Returns: "Possible"
// 
// 
// 
// 4)
// "AAABAAABB"
// "BAABAAABAABAABBBAAAAAABBAABBBBBBBABB"
// 
// Returns: "Impossible"
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
