#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class DevuAndGame {
public:
	string canWin(vector <int> nextLevel) {
    bool visited[100];
    for(int i=0;i<100;i++){
      visited[i] = false;
    }
    int cur = 0;
    while(visited[cur]==0){
      visited[cur] = 1;
      if(nextLevel[cur]==-1){
        return "Win";
      }
      cur = nextLevel[cur];
    }
    return "Lose";
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	DevuAndGame *obj;
	string answer;
	obj = new DevuAndGame();
	clock_t startTime = clock();
	answer = obj->canWin(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	string p1;
	
	{
	// ----- test 0 -----
	int t0[] = {1,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Win";
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1,0,-1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Lose";
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,1,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Lose";
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {29,33,28,16,-1,11,10,14,6,31,7,35,34,8,15,17,26,12,13,22,1,20,2,21,-1,5,19,9,18,4,25,32,3,30,23,10,27};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Win";
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {17,43,20,41,42,15,18,35,-1,31,7,33,23,33,-1,-1,0,33,19,12,42,-1,-1,9,9,-1,39,-1,31,46,-1,20,44,41,-1,-1,12,-1,36,-1,-1,6,47,10,2,4,1,29};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Win";
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {3,1,1,2,-1,4};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = "Lose";
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Devu loves to play games.
// This problem is about a game he recently played.
// In the game there are n locations, numbered 0 through n-1.
// Each location has one entrance and one exit.
// You are given a vector <int> nextLevel with n elements.
// For each i, nextLevel[i] describes the exit from location i.
// If nextLevel[i] is a number between 0 and n-1, inclusive, it means that the exit from location i leads to the entrance of location nextLevel[i].
// Otherwise, nextLevel[i] will be -1 and it means that if the player reaches this exit, they win the game.
// 
// 
// 
// 
// 
// Devu started the game by entering location 0.
// Return "Win" (quotes for clarity) if he can win the game.
// Otherwise, return "Lose".
// Note that the return value is case-sensitive.
// 
// 
// DEFINITION
// Class:DevuAndGame
// Method:canWin
// Parameters:vector <int>
// Returns:string
// Method signature:string canWin(vector <int> nextLevel)
// 
// 
// CONSTRAINTS
// -nextLevel will have between 1 and 50 elements, inclusive.
// -Each element in nextLevel will be either -1 or will be between 0 and n - 1, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {1, -1}
// 
// Returns: "Win"
// 
// Devu will start in location 0. The exit from this location will bring him to location 1, and when he reaches the exit from location 1 he wins the game.
// 
// 1)
// {1, 0, -1}
// 
// Returns: "Lose"
// 
// Devu will go back and forth between locations 0 and 1. He is unable to reach the exit from location 2.
// 
// 2)
// {0, 1, 2}
// 
// Returns: "Lose"
// 
// The exit from location 0 leads back to location 0. Devu is unable to reach the other locations.
// 
// 3)
// {29,33,28,16,-1,11,10,14,6,31,7,35,34,8,15,17,26,12,13,22,1,20,2,21,-1,5,19,9,18,4,25,32,3,30,23,10,27}
// 
// Returns: "Win"
// 
// There can be multiple x such that nextLevel[x] is -1.
// In order to win the game, Devu has to reach any single location with this property.
// 
// 4)
// {17,43,20,41,42,15,18,35,-1,31,7,33,23,33,-1,-1,0,33,19,12,42,-1,-1,9,9,-1,39,-1,31,46,-1,20,44,41,-1,-1,12,-1,36,-1,-1,6,47,10,2,4,1,29}
// 
// Returns: "Win"
// 
// 
// 
// 5)
// {3, 1, 1, 2, -1, 4}
// 
// Returns: "Lose"
// 
// In this game, Devu will go from location 0 to location 3, from there to location 2, and from there to location 1. There he will get stuck, as the exit from location 1 leads back to location 1.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
