#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class AnArray {
public:
	int solveProblem(vector <int> A, int K) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	AnArray *obj;
	int answer;
	obj = new AnArray();
	clock_t startTime = clock();
	answer = obj->solveProblem(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	int t0[] = {31,1,3,7,2,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 30;
	p2 = 1;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {4,5,2,25};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 100;
	p2 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {100000000,100000000,100000000};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1000000;
	p2 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {269,154,94,221,171,154,50,210,258,358,121,159,8,47,290,125,291,293,338,248,295,160,268,227,99,4,273};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 360;
	p2 = 114;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {1,1,1,1,1,1,1,1,1,1,1,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	p2 = 220;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// One day, Bob the Coder was wondering whether abstract programming problems can have applications in practice. The next day, he was selected to be on a quiz show. He will win one million dollars if he answers the following question:
// 
// Given a vector <int> A with N elements and an int K, count the number of tuples (p, q, r) such that 0 <= p < q < r < N and A[p] * A[q] * A[r] is divisible by K.
// 
// Please compute and return the answer to Bob's question.
// 
// DEFINITION
// Class:AnArray
// Method:solveProblem
// Parameters:vector <int>, int
// Returns:int
// Method signature:int solveProblem(vector <int> A, int K)
// 
// 
// CONSTRAINTS
// -A will contain between 3 and 2,000 elements, inclusive.
// -K will be between 1 and 1,000,000, inclusive.
// -Each element of A will be between 1 and 100,000,000, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {31, 1, 3, 7, 2, 5}
// 30
// 
// Returns: 1
// 
// The return value is 1 because there is exactly one valid tuple. The tuple is (2, 4, 5). It is valid because A[2] * A[4] * A[5] = 3 * 2 * 5 = 30.
// 
// 1)
// {4, 5, 2, 25}
// 100
// 
// Returns: 2
// 
// 
// 
// 2)
// {100000000, 100000000, 100000000}
// 1000000
// 
// Returns: 1
// 
// Note that the product A[p] * A[q] * A[r] doesn't have to fit into a 64-bit integer variable.
// 
// 3)
// {269, 154, 94, 221, 171, 154, 50, 210, 258, 358, 121, 159, 8, 47, 290, 125, 291, 293, 338, 248, 295, 160, 268, 227, 99, 4, 273}
// 360
// 
// Returns: 114
// 
// 
// 
// 4)
// {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
// 1
// 
// Returns: 220
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
