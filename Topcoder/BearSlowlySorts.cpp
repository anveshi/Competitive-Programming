#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class BearSlowlySorts {
public:
	int minMoves(vector <int> w) {
		int n = w.size();
		bool Ok = true;
		for(int i=0;i<n-1;i++){
			if(w[i]<w[i+1])
				continue;
			else
				Ok = false;
		}
		int m = *min_element(w.begin(), w.end());
		int M = *max_element(w.begin(), w.end());
		if(Ok)
			return 0;
		if(w[0]==m)
			return 1;
		if(w[n-1]==M)
			return 1;
		if(w[0]==M && w[n-1]==m)
			return 3;
		else
			return 2;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	BearSlowlySorts *obj;
	int answer;
	obj = new BearSlowlySorts();
	clock_t startTime = clock();
	answer = obj->minMoves(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	
	{
	// ----- test 0 -----
	int t0[] = {2,6,8,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {4,3,1,6,2,5};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {93,155,178,205,213,242,299,307,455,470,514,549,581,617,677};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {50,20,30,40,10};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {234,462,715,596,906,231,278,223,767,925,9,526,369,319,241,354,317,880,5,696};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Limak is a little polar bear.
// He has a vector <int> w containing a sequence of N distinct numbers.
// He wants to sort this sequence into ascending order.
// 
// Limak knows some fast sorting algorithms but in the real world such knowledge sometimes isn't enough.
// In order to sort the sequence w Limak must physically move the numbers into their correct places.
// Such a thing can be hard for a little bear.
// 
// In a single move Limak can take all elements he can reach and sort them into ascending order.
// The problem is that Limak's arms are too short.
// Regardless of where he stands, he can only reach N-1 consecutive elements of w.
// Hence, in each move he can either sort all elements except for the last one, or all elements except for the first one.
// 
// Limak can make the moves in any order he likes.
// Compute and return the smallest number of moves necessary to sort the given sequence w.
// 
// DEFINITION
// Class:BearSlowlySorts
// Method:minMoves
// Parameters:vector <int>
// Returns:int
// Method signature:int minMoves(vector <int> w)
// 
// 
// CONSTRAINTS
// -w will contain between 3 and 50 elements, inclusive.
// -Each element in w will be between 1 and 1000, inclusive.
// -w will contain distinct elements.
// 
// 
// EXAMPLES
// 
// 0)
// {2,6,8,5}
// 
// Returns: 1
// 
// Limak can sort this sequence in a single move.
// All he needs to do is to sort all elements except for the first one.
// In this single move Limak will pick up the elements {6,8,5} and reorder them into {5,6,8}.
// This will change the given w into {2,5,6,8}, and that is a sorted sequence.
// 
// 1)
// {4,3,1,6,2,5}
// 
// Returns: 2
// 
// One of the shortest ways is to sort first N-1 numbers first to get {1,2,3,4,6,5} and then to sort the last N-1 numbers.
// 
// 2)
// {93,155,178,205,213,242,299,307,455,470,514,549,581,617,677}
// 
// Returns: 0
// 
// This sequence is already sorted, no moves are necessary.
// 
// 3)
// {50,20,30,40,10}
// 
// Returns: 3
// 
// 
// 
// 4)
// {234,462,715,596,906,231,278,223,767,925,9,526,369,319,241,354,317,880,5,696}
// 
// Returns: 2
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!


// probabolity(|0>) = alpha0 * alpha0;
// probabolity(|0>) = alpha1 * alpha1;  