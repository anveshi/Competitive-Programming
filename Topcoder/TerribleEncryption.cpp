#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class TerribleEncryption {
public:
	string decrypt(string pool, vector <int> data, vector <int> keys) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, vector <int> p1, vector <int> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	TerribleEncryption *obj;
	string answer;
	obj = new TerribleEncryption();
	clock_t startTime = clock();
	answer = obj->decrypt(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	vector <int> p1;
	vector <int> p2;
	string p3;
	
	{
	// ----- test 0 -----
	p0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int t1[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {17,17,17,17,17,17,17,17,17,17,17,17,17,17,17};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "BJGNHDFPCMOKELI";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "AEIOUAEIOUaeiouaeiou";
	int t1[] = {1,2,3,4,5,6,7,8,9,10,1,2,3,4,5};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {2,3,4,5,6,7,8,9,10,11,13,15,16,17,18};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "EIOUAEIOUaEOeoe";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "abcdeffedcbaABCDEFFEDCBA";
	int t1[] = {10,10,10,10,10,10,10,10,10,10,10};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {3,7,11,13,17,19,23,29,31,37,41};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "bfbeAcedecB";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "abcdefghijklmnopqrstuvwxyz";
	int t1[] = {11,11,11,11,11,11,11,11,11,11,11,11,11,11,11};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {2,3,4,5,6,7,8,9,10,12,13,14,15,16,17};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "bcdbfcdfblgjldo";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "HmmBlahHmmBlah";
	int t1[] = {1,1,1,1,1,1,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {10,9,8,7,6,5,4};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "mmmmmmm";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You and your friends have decided to create your own encryption scheme (bad idea).  An encrypted message consists of 3 parts:
// 
//         1) A string called the pool 
//         2) A vector <int> called the data 
//         3) A vector <int> called the keys 
// 
// To decrypt character i of the message, first find the smallest positive integer k such that
//           (data[i] * k) % keys[i] = 1   
// Above % denotes the modulus operator.  Character i of the message will be character j in pool, where j is given by 
//           j = k % (length of pool)
// Return the decrypted string.  Constraints will ensure that the ith element of data is relatively prime to the ith element of keys.  In other words, the largest positive integer that divides data[i] and keys[i] will be 1, for all i.
// 
// 
// DEFINITION
// Class:TerribleEncryption
// Method:decrypt
// Parameters:string, vector <int>, vector <int>
// Returns:string
// Method signature:string decrypt(string pool, vector <int> data, vector <int> keys)
// 
// 
// CONSTRAINTS
// -pool will contain between 2 and 50 characters inclusive.
// -Each character in pool will be a letter ('A'-'Z', 'a'-'z').
// -data will contain between 1 and 50 elements inclusive.
// -keys will contain the same number of elements as data.
// -Each element of data will be between 1 and 100000 inclusive.
// -Each element of keys will be between 2 and 5000 inclusive.
// -Element i of keys will be relatively prime to element i of data.
// 
// 
// EXAMPLES
// 
// 0)
// "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
// {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}
// {17,17,17,17,17,17,17,17,17,17,17,17,17,17,17}
// 
// Returns: "BJGNHDFPCMOKELI"
// 
// 1)
// "AEIOUAEIOUaeiouaeiou"
// {1,2,3,4,5,6,7,8,9,10,1,2,3,4,5}
// {2,3,4,5,6,7,8,9,10,11,13,15,16,17,18}
// 
// Returns: "EIOUAEIOUaEOeoe"
// 
// 2)
// "abcdeffedcbaABCDEFFEDCBA"
// {10,10,10,10,10,10,10,10,10,10,10}
// {3,7,11,13,17,19,23,29,31,37,41}
// 
// Returns: "bfbeAcedecB"
// 
// 3)
// "abcdefghijklmnopqrstuvwxyz"
// {11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}
// {2,3,4,5,6,7,8,9,10,12,13,14,15,16,17}
// 
// Returns: "bcdbfcdfblgjldo"
// 
// 4)
// "HmmBlahHmmBlah"
// {1,1,1,1,1,1,1}
// {10,9,8,7,6,5,4}
// 
// Returns: "mmmmmmm"
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
