#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class VampireTreeDiv2 {
public:
	int countMinSamples(vector <int> A, vector <int> B) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	VampireTreeDiv2 *obj;
	int answer;
	obj = new VampireTreeDiv2();
	clock_t startTime = clock();
	answer = obj->countMinSamples(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	vector <int> p1;
	int p2;
	
	{
	// ----- test 0 -----
	int t0[] = {0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {0,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {0,0,2,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,-1,-1,-1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {0,1,2,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,-1,-1,-1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {0,1,1,2,1,2,2,5,7,6,5,10,6,6,12,6,6,2,8,0,16,5,8,2,14};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,-1,-1,-1,0,-1,-1,-1,2,7,10,11,7,9,-1,5,-1,15,4,7,9,-1,13,6,24};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 78;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {0,1,0,3,0,5,0,7,0,9,0,11,0,13,0,15,0,17,0,19,0,21,0,23,0,25,0,27,0,29,0,31,0,33,0,35,0,37,0,39,0,41,0,43,0,45,0,47,0,49,0,51,0,53,0,55,0,57,0,59,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 73741818;
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are a genealogist specializing in family trees of vampires. Vampire family trees differ from human family trees. In particular, there are two ways how a vampire can be "born":
// 
// 
// A living human can be turned into a vampire (the technical term here is "sired") by an existing vampire. In this case we call the older vampire the master and the newly created vampire the servant of that master.
// Two existing vampires can have a vampire child. In this case we call the two original vampires parents and the new vampire their child. Note that there are no restrictions on the two parent vampires. In particular, their genders and their ancestry can be arbitrary. Any two vampires can have a child.
// 
// 
// You are now studying one particular family of vampires. These vampires have all been created from a single vampire: the True Ancestor. This special vampire has no master and no parents. There are n vampires in the family. They are numbered 0 through n-1 in the order in which they were born, with vampire 0 being the True Ancestor.
// 
// You are given a description of the family tree in the vector <int>s A and B, each with n-1 elements. For each i between 1 and n-1, inclusive, the values A[i-1] and B[i-1] describe either the master or the parents of vampire i. If vampire i has a master then A[i-1] will be the number of its master and B[i-1] will be equal to -1. Otherwise, A[i-1] and B[i-1] will be the numbers of the two parents of vampire i.
// 
// In this particular family it is pretty rare for two vampires to have a child. More precisely, there are at most 15 vampires with two parents each.
// 
// You would like to select a representative sample of vampires from this family. The sample must have the following properties:
// 
// You need to select at least one vampire from each master/servant and also from each parent/child relationship.
// The total number of vampires in your sample must be as small as possible.
// 
// 
// Find and return the number of ways in which you can select the sample, modulo 10^9+7.
// 
// 
// DEFINITION
// Class:VampireTreeDiv2
// Method:countMinSamples
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int countMinSamples(vector <int> A, vector <int> B)
// 
// 
// NOTES
// -Please pay attention to the unusual time limit.
// 
// 
// CONSTRAINTS
// -A will contain between 1 and 999 elements, inclusive.
// -A and B will contain the same number of elements.
// -There are no more than 15 elements of B that are not equal to -1.
// -0 <= A[i] <= i for all valid i.
// --1 <= B[i] <= i for all valid i.
// -A[i] != B[i] for all valid i.
// 
// 
// EXAMPLES
// 
// 0)
// {0}
// {-1}
// 
// Returns: 2
// 
// There are two vampires.
// The True Ancestor (vampire 0) is the master of vampire 1.
// As vampires 0 and 1 are in a master/servant relationship, we are required to select at least one of them.
// 
// There are two valid samples.
// One of them is {0} and the other is {1}.
// The sample {0, 1} is not a valid sample because it contains too many vampires.
// 
// 
// 1)
// {0, 1}
// {-1, 0}
// 
// Returns: 3
// 
// In this test case there are three vampires.
// As in Example 0, vampire 0 is the master of vampire 1.
// Then, vampires 1 and 0 are the parents of vampire 2.
// 
// According to the problem statement:
// 
// Vampires 0 and 1 are in a master/servant relationship, so we have to select at least one of them.
// Vampires 0 and 2 are in a parent/child relationship, so we have to select at least one of them.
// Vampires 1 and 2 are in a parent/child relationship, so we have to select at least one of them.
// 
// 
// Clearly, this means we have to select at least two vampires.
// On the other hand, we can easily verify that each of the 3 samples {0, 1}, {0, 2}, and {1, 2} is valid.
// 
// 
// 2)
// {0, 0, 2, 2}
// {-1, -1, -1, -1}
// 
// Returns: 2
// 
// 
// 
// 3)
// {0, 1, 2, 3}
// {-1, -1, -1, -1}
// 
// Returns: 1
// 
// 
// 
// 4)
// {0, 1, 1, 2, 1, 2, 2, 5, 7, 6, 5, 10, 6, 6, 12, 6, 6, 2, 8, 0, 16, 5, 8, 2, 14}
// {-1, -1, -1, -1, 0, -1, -1, -1, 2, 7, 10, 11, 7, 9, -1, 5, -1, 15, 4, 7, 9, -1, 13, 6, 24}
// 
// Returns: 78
// 
// 
// 
// 5)
// {0,1,0,3,0,5,0,7,0,9,0,11,0,13,0,15,0,17,0,19,0,21,0,23,0,25,0,27,0,29,0,31,0,33,0,35,0,37,0,39,0,41,0,43,0,45,0,47,0,49,0,51,0,53,0,55,0,57,0,59,0}
// {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1}
// 
// Returns: 73741818
// 
// The answer is 1073741825 mod 10^9+7 which is 73741818.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
