#include <bits/stdc++.h>
#define pb push_back
#define mp make_pair
typedef long long LL;

using namespace std;


class BearChairs {
public:
	vector <int> findPositions(vector <int> atLeast, int d) {
		int n = atLeast.size();
		vector <int> v, Ans;
		v.clear();Ans.clear();

		int inf = 2000000000;
		v.push_back(-inf);
		v.push_back(atLeast[0]);
		Ans.push_back(atLeast[0]);
		v.push_back(inf);

		for(int i=1;i<n;i++){
			int pos = atLeast[i];
			int put = inf;

			for(int j=1;j<v.size();j++){
				int l = v[j-1];
				int r = v[j];
				if(l < pos && r > pos){
					if(pos-l>=d && r-pos>=d){
						put = min(put, pos);
					}
				}
				if(r-l>=2*d && l+d >= pos)
					put = min(put, l+d);
			}
			Ans.push_back(put);
			v.push_back(put);
			sort(v.begin(), v.end());
		}
		return Ans;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, int p1, bool hasAnswer, vector <int> p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << p1;
	cout << "]" << endl;
	BearChairs *obj;
	vector <int> answer;
	obj = new BearChairs();
	clock_t startTime = clock();
	answer = obj->findPositions(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p2.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p2[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p2.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p2[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	vector <int> p2;
	
	{
	// ----- test 0 -----
	int t0[] = {1,21,11,7};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 10;
	int t2[] = {1,21,11,31};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {1,21,11,7};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 11;
	int t2[] = {1,21,32,43};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1000000,1000000,1000000,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1000000;
	int t2[] = {1000000,2000000,3000000,4000000};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {1000000,1000000,1000000,1};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 999999;
	int t2[] = {1000000,1999999,2999998,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// I guess you have never seen a bear eating at a table.
// The reason is simple: bears don't use tables.
// However, they may sometimes decide to sit on a chair while eating.
// 
// Bear Limak is a waiter in a huge restaurant for bears.
// The restaurant has infinitely many chairs.
// The chairs are arranged in a single long row.
// In order, they are numbered using all positive integers: 1, 2, 3, ...
// Chair number 1 is closest to the entrance to the restaurant.
// 
// A bear takes a lot of space while eating, and all bears value their personal space.
// Limak knows that there is a universal constant d with the following meaning:
// Whenever two bears sit on chairs, their chair numbers must differ by d or more.
// For example, if d=10, you can have two bears in chairs 47 and 57, but you cannot have bears in chairs 47 and 56.
// 
// The restaurant just opened for the day and all chairs are empty.
// During the day exactly N guests arrived, one at a time.
// Whenever a guest arrived, Limak assigned them a chair.
// Each guest stayed in the restaurant in their assigned chair until the end of the day.
// 
// Generally, guests don't like to be seated close to the entrance because of the noise from the street.
// You are given a vector <int> atLeast with N elements: one for each guest, in order.
// For each i from 0 to N-1, guest i came with a request: "My chair number must be greater than or equal to atLeast[i]."
// 
// When seating a guest, Limak always assigns them the smallest available chair number.
// (That is, the smallest chair number that matches the guest's request and is at least d away from each of the bears who are already in the restaurant.)
// Return a vector <int> with N elements: for each guest, in the order in which they arrived, the number of the chair where they will be seated.
// 
// DEFINITION
// Class:BearChairs
// Method:findPositions
// Parameters:vector <int>, int
// Returns:vector <int>
// Method signature:vector <int> findPositions(vector <int> atLeast, int d)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 1000, inclusive.
// -atLeast will have exactly N elements.
// -Each element in atLeast will be between 1 and 10^6, inclusive.
// -d will be between 1 and 10^6, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// {1,21,11,7}
// 10
// 
// Returns: {1, 21, 11, 31 }
// 
// Here is what will happen:
// 
// Guest 0 wants a chair with a number greater or equal to 1. He gets the chair 1.
// Guest 1 wants a chair with a number greater or equal to 21. She gets the chair 21.
// Guest 2 wants a chair with a number greater or equal to 11. He gets the chair 11. Note that this chair is still far enough from each of the two bears who are already sitting in the restaurant.
// Guest 3 wants a chair with a number greater or equal to 7. The smallest available chair is chair number 31. All free chairs with smaller numbers are too close to some of the previous guests.
// 
// 
// 1)
// {1,21,11,7}
// 11
// 
// Returns: {1, 21, 32, 43 }
// 
// The guests have the same requests as in Example 0 but d is larger. Thus, guest 2 doesn't fit between guests 0 and 1 and must be seated in a chair with a larger number.
// 
// 2)
// {1000000,1000000,1000000,1}
// 1000000
// 
// Returns: {1000000, 2000000, 3000000, 4000000 }
// 
// 
// 
// 3)
// {1000000,1000000,1000000,1}
// 999999
// 
// Returns: {1000000, 1999999, 2999998, 1 }
// 
// 
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
