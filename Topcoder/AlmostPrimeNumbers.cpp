#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define LL long long int
#define pb push_back
#define mp make_pair

using namespace std;


class AlmostPrimeNumbers {
public:
	int getNext(int m) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << p0;
	cout << "]" << endl;
	AlmostPrimeNumbers *obj;
	int answer;
	obj = new AlmostPrimeNumbers();
	clock_t startTime = clock();
	answer = obj->getNext(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	
	{
	// ----- test 0 -----
	p0 = 200;
	p1 = 209;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 666;
	p1 = 667;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 1000;
	p1 = 1003;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 1591;
	p1 = 1633;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 6;
	p1 = 121;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// An integer N greater than 1 is called almost prime if and only if the following conditions hold:
// 
// N is not prime.  In other words, it is divisible by some positive integer other than 1 and itself.
// Each positive divisor of N (other than 1) is greater than 10.
// 
// 
// Return the smallest almost prime number that is strictly greater than m.
// 
// 
// DEFINITION
// Class:AlmostPrimeNumbers
// Method:getNext
// Parameters:int
// Returns:int
// Method signature:int getNext(int m)
// 
// 
// CONSTRAINTS
// -m will be between 1 and 10^6, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 200
// 
// Returns: 209
// 
// 201 is divisible by 3, which is less than 10, so 201 is not almost prime.  202, 204, 206, and 208 are all divisible by 2.  203 is divisible by 7, 205 by 5, and 207 by 3.  So, the smallest almost prime number greater than 200 is 209 = 11*19.
// 
// 1)
// 666
// 
// Returns: 667
// 
// 667 = 23*29, so it's almost prime.
// 
// 2)
// 1000
// 
// Returns: 1003
// 
// 3)
// 1591
// 
// Returns: 1633
// 
// 4)
// 6
// 
// Returns: 121
// 
// The smallest almost prime number is 11*11 = 121.
// 
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
